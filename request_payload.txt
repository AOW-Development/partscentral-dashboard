SYSTEM / PROMPT FOR LLM:
-----------------------
You are an expert backend engineer familiar with Prisma (v6+), Node.js, and payments best practices. Your task: given an incoming HTTP request body shaped like the provided "admin order payload" (same structure as createOrderFromAdmin), produce the exact sequence of database operations to update an existing order and its related tables.

Requirements & rules:
1. Use a single database transaction for the update. If anything fails, roll back the entire transaction.
2. The `paymentInfo` in the payload is **NOT** a JSON column on `order`. Instead:
   - Map `paymentInfo` to the separate `payment` table/model.
   - If a `payment` already exists for the `order` (find by `orderId`), update it; otherwise create it.
   - Parse `cardData.expirationDate` in `MM/YY` or `MM/YYYY` format to a `Date` representing the first day of the expiry month (e.g., "05/25" -> `new Date(2025, 4, 1)`).
   - Store **only** `last4`, `cardBrand`, `cardExpiry` in payment row. If full PAN or CVV are present in payload, **do not** persist them in plain text: instead the LLM should recommend tokenization or using a PCI-compliant vault. If user explicitly requests storing raw PAN, warn about PCI compliance and recommend against it.
   - Map payload fields: provider -> `provider`, paymentMethod -> `method`, status -> `status`, amount -> `amount`, currency -> `currency`, approvelCode (or approvalCode) -> `approvalCode` (use consistent spelling), charged -> boolean `charged`, entity -> `entity` (default 'NA' if missing).

3. Order fields:
   - Treat `billingInfo`, `shippingInfo` as snapshots: update `order.billingSnapshot` and `order.shippingSnapshot` by setting them (prisma `Json` or object field — use `{ set: ... }` if field is `Json`).
   - For nullable DateTime fields (`invoiceSentAt`, `invoiceConfirmedAt`, `poSentAt`, `poConfirmAt`, `orderDate`), convert ISO string to `Date` objects for DB and set `null` when payload has `null`.
   - Map warranty strings to Prisma enum using the following mapping:
     - '30 Days' -> 'WARRANTY_30_DAYS'
     - '60 Days' -> 'WARRANTY_60_DAYS'
     - '90 Days' -> 'WARRANTY_90_DAYS'
     - '6 Months' -> 'WARRANTY_6_MONTHS'
     - '1 Year' -> 'WARRANTY_1_YEAR'
     - default -> 'WARRANTY_30_DAYS'
   - For JSON fields like `customerNotes`, `yardNotes`, `billingSnapshot`, `shippingSnapshot`, use `{ set: <value> }` in Prisma update if the schema field is `Json` or `Json?`.

4. Items (`cartItems`):
   - For each `cartItems` entry: if an `orderItem` with same `sku` exists -> update quantity, unitPrice, lineTotal, specification, milesPromised, pictureUrl, pictureStatus, metadata.
   - If it does not exist -> create it, linking `productVariantId` (find by SKU) and filling `makeName`, `modelName`, `yearName`, `partName` using `productVariant` -> `product` -> `modelYear` -> `model` -> `make`.
   - Remove `orderItem` records that are no longer present in incoming `cartItems` (delete by id).
   - Calculate `lineTotal = price * quantity`. Parse numeric fields safely.

5. YardInfo:
   - If `yardInfo` present: if existing yardInfo (find by `orderId`) exists -> push a new `yardHistory` row capturing previous yard info and then update `yardInfo`. If none exists -> create new `yardInfo`.
   - `yardOwnShippingInfo` handling: if payload value is `null` -> set `Prisma.JsonNull`, if `undefined` -> leave unchanged, else set to payload.

6. Payment record timestamps:
   - Use `paidAt` = now (`new Date()`) when updating/creating payment if `status` indicates paid. Otherwise, leave `paidAt` as null or set to now per your business rule (explicitly require `status === 'PAID'` or truthy `charged` to mark paid).

7. ID handling and upsert logic:
   - Use `findUnique/findFirst` to detect existing records.
   - Use `update` with proper `where` clauses when updating resources.
   - Use `create` when record is missing.
   - Do not pass unknown fields to Prisma `order.update` (Prisma will throw). Only include fields that exist on the `order` model or nested relation operations.

8. Validation & sanitization:
   - Ensure `cartItems[].sku` (or `id`) exists — if missing, throw an error and abort.
   - Cast numeric strings to numbers using `parseFloat` and handle NaN -> 0.
   - For phone/email, fall back to defaults when missing as your create logic uses.

9. Error messages & return:
   - Return the updated `order` object including `customer`, `items`, `payments`, `yardInfo`, `yardHistory`, `address` (same `include` you already use).
   - On errors return helpful messages like "Order with ID <id> not found", "Product variant with SKU <sku> not found", "Invalid card expiration format".

10. Output expected from you (LLM):
   - Provide a step-by-step pseudocode sequence of operations OR a complete TypeScript function using Prisma transaction that implements the update exactly.
   - Use the same function naming / variable names as the project's style (e.g., `updateOrder(orderId: string, data: any)`).
   - Make the implementation robust and ready to drop into the codebase (no placeholders).
   - Highlight any security/P.I.I./PCI concerns and recommend using tokenization/vault for sensitive card details.

Example Input (JSON):
{
  "billingInfo": { "firstName": "Alice", "address": "...", ... },
  "shippingInfo": { ... },
  "customerInfo": { ... },
  "cartItems": [{ "sku": "ENG-123-01", "quantity": 1, "price": 450.00, "warranty":"30 Days" }],
  "paymentInfo": {
    "paymentMethod": "card",
    "status": "PENDING",
    "amount": 450.00,
    "currency": "USD",
    "provider": "STRIPE",
    "cardData": {
      "cardNumber": "4242424242424242",
      "cardholderName": "Alice Example",
      "expirationDate": "05/25",
      "securityCode": "123",
      "last4": "4242",
      "brand": "Visa"
    },
    "approvelCode": "APPROV-1",
    "charged": false
  },
  "totalAmount": 450.00,
  "subtotal": 400.00,
  "warranty": "30 Days",
  "orderDate": "2025-09-12T00:00:00.000Z",
  ...
}

Expected DB action summary:
1. tx.order.findUnique(orderId) -> if not found throw
2. Extract paymentInfo, yardInfo, billingInfo, shippingInfo, cartItems
3. Handle yardInfo: (archive -> create/update)
4. Sync order items (update/create/delete)
5. Build `updateData` for order (convert dates, set snapshots via Json set, map enums)
6. tx.order.update({ where: {id}, data: updateData }) — include relations
7. Handle paymentInfo: find tx.payment.findFirst({ where: { orderId } }) -> update or create. When writing to DB only persist non-sensitive fields (last4, brand, expiry). Recommend to replace full PAN/CVV with token.

Security note (mandatory): Do not store raw card numbers (PAN) or CVV in plaintext in your DB. Instead:
- Prefer storing payment `token` returned by Stripe/your gateway.
- Store `last4`, `cardBrand` and `cardExpiry`, and any gateway reference/transaction id.
- If you must store PAN for legacy reasons, warn and require PCI-DSS compliance, encryption at rest, and restricted access.

Finish with: Return the updated order (including `payments`) and log any created/updated IDs.

---

When asked, produce a TypeScript implementation that follows the above steps exactly using `prisma.$transaction(async tx => { ... })`. Ensure `paymentInfo` is treated as separate table operations and do not include `paymentInfo` directly in `tx.order.update` payload.

If you understand, output the full TypeScript function implementing this `updateOrder` behavior.
